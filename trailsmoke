import maya.mel
import maya.cmds as cmds

#===============================================================================================================
#   create particle system
#
#===============================================================================================================
#selected locator
sel = cmds.ls(selection =True)
#create particle system
nparN = cmds.nParticle()
cmds.select(clear=True)
emitN = cmds.emitter()
cmds.setAttr (emitN+".scaleRateByObjectSize", 0)
cmds.connectDynamic( nparN , em=emitN)
shapes = cmds.listRelatives(nparN, shapes=True)

#setup parcticle shape
cmds.setAttr (shapes[0]+".lifespanMode", 2)
cmds.setAttr (shapes[0]+".lifespan", 4)
cmds.setAttr (shapes[0]+".lifespanRandom", 1)
cmds.setAttr (shapes[0]+".dynamicsWeight", 0.9)
cmds.setAttr (shapes[0]+".pointMass", 5)

#setup radius
cmds.setAttr (shapes[0]+".radius", 700)
cmds.setAttr (shapes[0]+".radiusScaleInput", 2)
cmds.setAttr (shapes[0]+".radiusScaleRandomize", 0.25)
cmds.setAttr (shapes[0]+".radiusScale[0].radiusScale_Position", 0)
cmds.setAttr (shapes[0]+".radiusScale[0].radiusScale_FloatValue", 0.14)
cmds.setAttr (shapes[0]+".radiusScale[0].radiusScale_Interp", 3)
cmds.setAttr (shapes[0]+".radiusScale[1].radiusScale_Interp", 3)
cmds.setAttr (shapes[0]+".radiusScale[1].radiusScale_Position", 1)
cmds.setAttr (shapes[0]+".radiusScale[1].radiusScale_FloatValue", 1)
cmds.setAttr (shapes[0]+".radiusScale[2].radiusScale_Interp", 3)
cmds.setAttr (shapes[0]+".radiusScale[2].radiusScale_Position", 0.45)
cmds.setAttr (shapes[0]+".radiusScale[2].radiusScale_FloatValue", 0.76)
cmds.setAttr (shapes[0]+".radiusScale[3].radiusScale_Interp", 3)
cmds.setAttr (shapes[0]+".radiusScale[3].radiusScale_Position", 0.2)
cmds.setAttr (shapes[0]+".radiusScale[3].radiusScale_FloatValue", 0.26)

#setup opacity
cmds.setAttr (shapes[0]+".opacityScaleInput", 2)
cmds.setAttr (shapes[0]+".opacityScaleRandomize", 0.21)
cmds.setAttr (shapes[0]+".opacityScale[0].opacityScale_Position", 0)
cmds.setAttr (shapes[0]+".opacityScale[0].opacityScale_FloatValue", 1)
cmds.setAttr (shapes[0]+".opacityScale[0].opacityScale_Interp", 3)
cmds.setAttr (shapes[0]+".opacityScale[1].opacityScale_FloatValue", 0.58)
cmds.setAttr (shapes[0]+".opacityScale[1].opacityScale_Interp", 3)
cmds.setAttr (shapes[0]+".opacityScale[1].opacityScale_FloatValue", 0)
cmds.setAttr (shapes[0]+".opacityScale[2].opacityScale_Interp", 3)
cmds.setAttr (shapes[0]+".opacityScale[2].opacityScale_Position", 0.0695652)
cmds.setAttr (shapes[0]+".opacityScale[2].opacityScale_FloatValue", 0.4)
cmds.setAttr (shapes[0]+".opacityScale[3].opacityScale_Interp", 3)
cmds.setAttr (shapes[0]+".opacityScale[3].opacityScale_Position", 0.182609)
cmds.setAttr (shapes[0]+".opacityScale[3].opacityScale_FloatValue", 0.14)
cmds.setAttr (shapes[0]+".opacityScale[4].opacityScale_Position", 1)
cmds.setAttr (shapes[0]+".opacityScale[4].opacityScale_FloatValue", 0)


#setup color
cmds.setAttr (shapes[0]+".colorInput", 2)
cmds.setAttr (shapes[0]+".colorRandomize", 0.21)
cmds.setAttr (shapes[0]+".color[1].color_Color", 0, 0, 0,type="double3")
cmds.setAttr (shapes[0]+".color[2].color_Position", 0.0608696)
cmds.setAttr (shapes[0]+".color[2].color_Interp", 1)
cmds.setAttr (shapes[0]+".color[2].color_Color", 1, 1, 0,type="double3")
cmds.setAttr (shapes[0]+".color[3].color_Position", 0.13913)
cmds.setAttr (shapes[0]+".color[3].color_Interp", 1)
cmds.setAttr (shapes[0]+".color[3].color_Color", 0.916667, 0.266976, 0,type="double3")
cmds.setAttr (shapes[0]+".color[4].color_Interp", 1)
cmds.setAttr (shapes[0]+".color[4].color_Color", 0.341, 0.341, 0.341,type="double3")
cmds.setAttr (shapes[0]+".color[4].color_Position", 0.278261)
cmds.setAttr (shapes[0]+".color[5].color_Interp", 1)
cmds.setAttr (shapes[0]+".color[5].color_Color", 0.209, 0.209, 0.209,type="double3")

#seup incandescence
cmds.setAttr (shapes[0]+".incandescenceInput", 2)
cmds.setAttr (shapes[0]+".incandescenceRandomize", 0.737828)

cmds.setAttr (shapes[0]+".incandescence[0].incandescence_Color", 1, 1, 1, type="double3")
cmds.setAttr (shapes[0]+".incandescence[0].incandescence_Position", 0)

cmds.setAttr (shapes[0]+".incandescence[1].incandescence_Color", 1, 1, 0, type="double3")
cmds.setAttr (shapes[0]+".incandescence[1].incandescence_Position", 0.0695652)
cmds.setAttr (shapes[0]+".incandescence[1].incandescence_Interp", 1)

cmds.setAttr (shapes[0]+".incandescence[2].incandescence_Interp", 1)
cmds.setAttr (shapes[0]+".incandescence[2].incandescence_Color", 1, 0.266667, 0, type="double3")
cmds.setAttr (shapes[0]+".incandescence[2].incandescence_Position", 0.165217)

cmds.setAttr (shapes[0]+".incandescence[3].incandescence_Interp", 1)
cmds.setAttr (shapes[0]+".incandescence[3].incandescence_Position", 0.347826)
cmds.setAttr (shapes[0]+".incandescence[3].incandescence_Color", 0.122, 0.122, 0.122, type="double3")

cmds.setAttr (shapes[0]+".incandescence[4].incandescence_Interp", 1)
cmds.setAttr (shapes[0]+".incandescence[4].incandescence_Position", 1)
cmds.setAttr (shapes[0]+".incandescence[4].incandescence_Color", 0, 0, 0, type="double3")


#===============================================================================================================
#===============================================================================================================

#parent emitter
emitt_grp = cmds.spaceLocator ()
cmds.parent(emitN[0],emitt_grp)

cmds.pointConstraint ( sel[0],emitt_grp[0] )
cmds.orientConstraint ( sel[0],emitt_grp[0] )



#===============================================================================================================
#===============================================================================================================
#
# create shader
#
#===============================================================================================================
#===============================================================================================================


# Create and connect rnk_vertex_data node
rsNameC = mc.shadingNode('ryeRSLTemplate', asShader=True)
rsName = cmds.rename( rsNameC,"Sprite_shader")
mc.setAttr(rsName + '.shaderType', 'rye_surface', type='string')

print rsName

#set shader standarts
cmds.setAttr(rsName + '.useOpacity',1)
cmds.setAttr(rsName + '.useIndirectDiffuse',0)
cmds.setAttr(rsName + '.useReflection',0)
cmds.setAttr(rsName + ".diffuseIntensity", 1)
cmds.setAttr(rsName + ".orenNayarRoughness", 0.6)
#cmds.setAttr(rsName + ".useDirectDiffuse", 0)
cmds.setAttr(rsName + ".useDirectDiffuse", 1)
cmds.setAttr(rsName + ".useSubsurfaceScattering", 0)
cmds.setAttr(rsName + ".useSpecular", 0)
#cmds.setAttr(rsName + ".useSubsurfaceScattering", 1)
#cmds.setAttr(rsName + ".sssDmfpLength", 50)

# Create rnk particlesampler
samplerName = mc.shadingNode('rnk_particle_sampler_info', asUtility=True)
#connect sampler to shader
#mc.connectAttr(samplerName + '.outRGB', rsName + '.sssAlbedo')



#create ramp
rampT = cmds.shadingNode('ramp', asTexture=True,n="spriteShape_noise")
tex1 = cmds.shadingNode('place2dTexture', asUtility=True)
mc.connectAttr(tex1 + '.outUvFilterSize', rampT + '.uvFilterSize')
mc.connectAttr(tex1 + '.outUV', rampT + '.uv')
#setup ramp
cmds.setAttr (rampT+".colorEntryList[2].color" , 0, 0, 0,type="double3")
cmds.setAttr (rampT+".colorEntryList[2].position", 0.75)
cmds.setAttr (rampT+".type", 4)
cmds.setAttr (rampT+".colorEntryList[1].color" , 0.074, 0.074, 0.074,type="double3")
cmds.setAttr (rampT+".colorEntryList[1].position", 0.544)
cmds.setAttr (rampT+".colorEntryList[0].color" , 1, 1, 1,type="double3")
cmds.setAttr (rampT+".colorEntryList[3].position", 0.166)
cmds.setAttr (rampT+".colorEntryList[3].color",0.612, 0.612, 0.612,type="double3")
cmds.setAttr (rampT+".noise", 0.24)
cmds.setAttr (rampT+".noiseFreq", 0.33)
cmds.setAttr (rampT+".valNoise", 0.3)
cmds.setAttr (rampT+".valNoiseFreq", 0.7)

#create multyplier
multi = cmds.shadingNode('multiplyDivide', asUtility=True,n='opacityMulti')

#connect ramp with opacity
mc.connectAttr(multi + '.output', rsName + '.opacity')
mc.connectAttr(samplerName + '.outOpacity', multi + '.input2X')
mc.connectAttr(samplerName + '.outOpacity', multi + '.input2Y')
mc.connectAttr(samplerName + '.outOpacity', multi + '.input2Z')

#create noise
noiseT = cmds.shadingNode('noise', asTexture=True,n='extraNoise')
tex2 = cmds.shadingNode('place2dTexture', asUtility=True)
mc.connectAttr(tex2 + '.outUvFilterSize', noiseT + '.uvFilterSize')
mc.connectAttr(tex2 + '.outUV', noiseT + '.uv')
cmds.setAttr (noiseT+".frequency", 4)

#create multyplier2
multi2 = cmds.shadingNode('multiplyDivide', asUtility=True,n='extraNoiseMulti')

#add noise to network
mc.connectAttr(noiseT + '.outColor', multi2 + '.input1')
mc.connectAttr(rampT + '.outColor', multi2 + '.input2')
mc.connectAttr(multi2 + '.output', multi + '.input1')

#create multyplier3
multi3 = cmds.shadingNode('multiplyDivide', asUtility=True,n='ageMulti')

#connect to shader
mc.connectAttr(samplerName + '.outRGB', multi3 + '.input2')
mc.connectAttr(multi2 + '.output', multi3 + '.input1')
mc.connectAttr(multi3 + '.output', rsName + '.surfaceColor')
#mc.connectAttr(rampT + '.outColorR',rsName + '.specularRoughness')

#create multyplier4
multi4 = cmds.shadingNode('multiplyDivide', asUtility=True,n='incandescenceBoost')
#connect multiper incandescence
mc.connectAttr(multi3 + '.output', multi4 + '.input1')
mc.connectAttr(multi4 + '.outputY', rsName + '.incandescence')
cmds.setAttr(multi4 + ".input2Y", 3.5)

#assign shader
select (shapes[0],r=True)
hyperShade(a=rsName)


#create displacment
rsDisC = mc.shadingNode('ryeRSLTemplate', asShader=True)
rsDis = cmds.rename( rsNameC,"sprite_displacment")
mc.setAttr(rsDis + '.shaderType', 'rye_displacement', type='string')
#connect to shading group
SGname = cmds.listConnections(rsName + '.outColor',type="shadingEngine")
mc.connectAttr(rsDis + '.message', SGname[0] + '.displacementShader')

cmds.setAttr (rsDis  +".remap0", -20)
cmds.setAttr (rsDis  +".remap1", 20)

#create ramp
rampT2 = cmds.shadingNode('ramp', asTexture=True,n='displacementRamp')
tex2 = cmds.shadingNode('place2dTexture', asUtility=True)
mc.connectAttr(tex2 + '.outUvFilterSize', rampT2 + '.uvFilterSize')
mc.connectAttr(tex2 + '.outUV', rampT2 + '.uv')

cmds.setAttr (rampT2+".type", 4)
cmds.setAttr (rampT2+".colorEntryList[0].color" , 1, 1, 1,type="double3")
cmds.setAttr (rampT2+".colorEntryList[1].color" , 0.954, 0.954, 0.954,type="double3")
cmds.setAttr (rampT2+".colorEntryList[1].position", 0.344)
cmds.setAttr (rampT2+".colorEntryList[2].color" , 0, 0, 0,type="double3")
cmds.setAttr (rampT2+".colorEntryList[2].position", 0.6)
#conncet ramp to displacement
mc.connectAttr(rampT2 + '.outColorR', rsDis  + '.input')

#create remaper
map1 = cmds.shadingNode ('remapValue',asUtility=True, n='ageNoiseFreg')
cmds.setAttr (map1+".value[0].value_Interp", 1)
cmds.setAttr (map1+".value[0].value_FloatValue", 0.08)
cmds.setAttr (map1+".value[0].value_Position", 0)
cmds.setAttr (map1+".value[1].value_FloatValue", 1)
cmds.setAttr (map1+".value[1].value_Position", 0.17)


map2 = cmds.shadingNode ('remapValue',asUtility=True,n='ageNoise')
cmds.setAttr (map2+".value[0].value_Interp", 1)
cmds.setAttr (map2+".value[0].value_FloatValue", 0.08)
cmds.setAttr (map2+".value[0].value_Position", 0)
cmds.setAttr (map2+".value[1].value_FloatValue", 1)
cmds.setAttr (map2+".value[1].value_Position", 0.17)


#connect remappers
mc.connectAttr(map1 + '.outValue', rampT + '.noiseFreq')
mc.connectAttr(map2 + '.outValue', rampT + '.noise')
mc.connectAttr(samplerName + '.outOpacity', map1 + '.inputValue')
mc.connectAttr(samplerName + '.outOpacity', map2 + '.inputValue')

# create multi5 
multi5 = cmds.shadingNode('multiplyDivide', asUtility=True,n='ageUserColor')
#usercolor 1
mc.connectAttr(samplerName + '.outAge', multi5 + '.input1X')
mc.connectAttr(samplerName + '.outAge', multi5 + '.input1Y')
mc.connectAttr(samplerName + '.outAge', multi5 + '.input1Z')
mc.connectAttr(multi3 + '.output', multi5 + '.input1')
mc.connectAttr(samplerName + '.outAge', multi5 + '.input2X')
mc.connectAttr(samplerName + '.outAge', multi5 + '.input2Y')
mc.connectAttr(samplerName + '.outAge', multi5 + '.input2Z')
mc.connectAttr(multi5+ '.output', rsName + '.utilityColor1')

# create multi6
multi6 = cmds.shadingNode('multiplyDivide', asUtility=True,n='IncandescenceRampUserColor')
# usercolor 2
mc.connectAttr(samplerName +'.outIncandescence', multi6 + '.input1')
mc.connectAttr(multi3 + '.output', multi6 + '.input2')
mc.connectAttr(multi6+ '.output', rsName + '.utilityColor2')




#===============================================================================================================
#===============================================================================================================
# adding partilce expressions and foreces
#===============================================================================================================
#===============================================================================================================



cmds.select(clear=True)
tur = cmds.turbulence()
cmds.connectDynamic( nparN , f=tur)
cmds.setAttr (tur[0]+".attenuation", 0.3)
cmds.setAttr (tur[0]+".frequency", 0.0041)
cmds.setAttr (tur[0]+".noiseRatio", 0.0322)
cmds.setAttr (tur[0]+".noiseLevel", 2)
cmds.setAttr (tur[0]+".noiseLevel", 1)

#add attrPP
cmds.addAttr (shapes[0],ln="spriteTwistPP",dt="doubleArray")
cmds.addAttr (shapes[0],ln="spriteScaleXPP",dt="doubleArray")
cmds.addAttr (shapes[0],ln="spriteScaleYPP",dt="doubleArray")
cmds.addAttr (shapes[0],ln="radiusPP",dt="doubleArray")
cmds.addAttr (shapes[0],ln="ran",dt="doubleArray")
cmds.addAttr (shapes[0],ln= tur[0]+"_magnitude",dt="doubleArray")
cmds.addAttr (shapes[0],ln= "spriteRotation",dt="doubleArray")
cmds.addAttr (shapes[0],ln= "spriteRotationUPP",dt="doubleArray")

#rotation ramp
rotAy = cmds.arrayMapper( target=shapes[0], destAttr="spriteRotation", inputV='ageNormalized', type='ramp' )
cmds.setAttr (rotAy[0]+".maxValue", 3)
rotRamp = cmds.listConnections( rotAy[0]+'.computeNodeColor' )
cmds.setAttr (rotRamp[0]+".valNoiseFreq", 0.849372)
cmds.setAttr (rotRamp[0]+".valNoise", 0.2)
cmds.setAttr (rotRamp[0]+".colorEntryList[0].color", 1, 1, 1,type="double3")
cmds.setAttr (rotRamp[0]+".colorEntryList[1].color", 0.451, 0.451, 0.451, type="double3")
cmds.setAttr (rotRamp[0]+".colorEntryList[1].position", 0.17)
cmds.setAttr (rotRamp[0]+".colorEntryList[2].color", 0, 0, 0, type="double3")
cmds.setAttr (rotRamp[0]+".colorEntryList[2].position", 0.4)

#turblence map
turAy = cmds.arrayMapper( target=shapes[0], destAttr=tur[0]+"_magnitude", inputV='ageNormalized', type='ramp' )
cmds.setAttr (turAy[0]+".maxValue", 5000)
turRamp = cmds.listConnections( turAy[0]+'.computeNodeColor' )

cmds.setAttr (turRamp[0]+".colorEntryList[0].position", 0.0551)
cmds.setAttr (turRamp[0]+".colorEntryList[0].color", 1.001, 1.001, 1.001, type="double3")
cmds.setAttr (turRamp[0]+".colorEntryList[1].position", 0)
cmds.setAttr (turRamp[0]+".colorEntryList[1].color", 0, 0, 0, type="double3")
cmds.setAttr (turRamp[0]+".colorEntryList[3].position", 0.1551)
cmds.setAttr (turRamp[0]+".colorEntryList[3].color", 0.393, 0.393, 0.393,type="double3")
cmds.setAttr (turRamp[0]+".colorEntryList[2].position", 0.3851)
cmds.setAttr (turRamp[0]+".colorEntryList[2].color", 0, 0, 0, type="double3")


# create PP expression
exp1 = shapes[0]+".spriteTwistPP  = rand(-360,360);\n" 
exp2 = shapes[0]+".spriteScaleXPP  = " +shapes[0]+".radiusPP;\n"
exp3 = shapes[0]+".spriteScaleYPP  = " +shapes[0]+".radiusPP;\n"
exp5 = shapes[0]+".ran = rand(0,100);\n"
expC = exp1+exp2+exp3+exp5
cmds.dynExpression( shapes[0], s=expC , c=1 )

#exp4 = "if ("+shapes[0]+".ran > 50) "+shapes[0]+".spriteTwistPP  = " +shapes[0]+".spriteRotation;\n"
#exp6 = "if ("+shapes[0]+".ran < 50) "+shapes[0]+".spriteTwistPP  = " +shapes[0]+".spriteRotation;\n"
exp6 = shapes[0]+".spriteTwistPP  += " +shapes[0]+".spriteRotation;\n"
exp7 = shapes[0]+".spriteRotationUPP = rand(0,1);\n"
expA = exp7+exp6+exp2+exp3
cmds.dynExpression( shapes[0], s=expA, rad=1 )

cmds.setAttr (shapes[0]+".particleRenderType", 5)
cmds.setAttr (shapes[0]+".depthSort", 1)




#set renderglobals
#cmds.setAttr ("ryeRenderGlobals.gridSize", 256)
#cmds.setAttr ("ryeRenderGlobals.raytrace", 0)



